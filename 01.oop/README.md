### 00_create_classe

Реализуйте класс Counter, представляющий собой счётчик, хранящий неотрицательное целочисленное значение и позволяющий 
это значение изменять:

атрибут value должен хранить текущее значение счётчика (вначале равное нулю)
метод inc() должен увеличивать текущее значение на delta единиц (на 1 по умолчанию)
метод dec() должен уменьшать текущее значение на delta единиц (на 1 по умолчанию)
c = Counter()
c.inc()
c.inc()
c.inc(40)
c.value  # 42
c.dec()
c.dec(30)
c.value  # 11
c.dec(delta=100)
c.value  # 0

### 01_methode_init

Вам предстоит снова реализовать класс Counter. Но на этот раз счётчик будет иммутабельным и всё ещё неотрицательным целочисленным. 
Методы inc() и dec() должны возвращать новый счётчик с изменённым в большую или соответственно меньшую сторону значением value 
(по умолчанию счётчик изменяется на единицу).

c = Counter()
c.inc()  # возвращает новый объект класса
c.inc().value  # возвращает value нового объекта
В этой реализации вам нужно объявить в классе функцию-инициализатор, позволяющую задать начальное значение счётчика 
(атрибут value). Если же значение при инстанциировании не будет задано, следует принять его по умолчанию равным нулю.

Атрибут value первоначального объекта после применения методов должен всё ещё содержать неизменное значение.
Неизменность старого объекта и является условием иммутабильности.

c = Counter()
c.inc().inc(5).dec(2).value  # 4

# Старый экземпляр не должен изменяться
d = c.inc(100)
d.dec().value  # 99

forty_two = Counter(42)
forty_two.value  # 42
Внимание! В самом классе атрибут value не должен быть объявлен. Этот атрибут должен добавляться в объект только в инициализаторе.

### 02.HourClock

Реализуйте класс HourClock, который будет изображать часы с одной лишь часовой стрелкой. 
Текущее время (час) должно сообщать свойство hours. Это же свойство должно позволять 
изменять положение часовой стрелки (посредством сеттера). При изменении положения стрелки нужно контролировать,
чтобы значение оставалось в диапазоне 0..11 (часов).

clock = HourClock()
clock.hours  # 0
# в начале часовая стрелка всегда на нуле
clock.hours += 5
# ^ эквивалентно clock.hours = clock.hours + 5
clock.hours += 5
clock.hours  # 10
clock.hours += 5
clock.hours  # 3
clock.hours -= 4
clock.hours  # 11
clock.hours = 123
clock.hours  # 3
Подсказки
Используйте модульную арифметику

### 03.LimitedCounter

Вам дан класс Counter, реализующий счетчик с инкрементом и декрементом. Вам нужно реализовать класс-потомок LimitedCounter,
который будет отличаться от Counter тем, что при инициализации будет принимать в качестве аргумента лимит — 
максимальное возможное значение счетчика.

Требования к классу LimitedCounter:

Класс должен максимально использовать методы предка, если таковые переопределяет
Минимальное значение счетчика Counter — 0, должно оставаться таковым и для LimitedCounter
counter = LimitedCounter(limit=10)
counter.inc()
counter.inc(7)
counter.value  # 8
counter.dec(10)
counter.value  # 0
counter.inc(7)
counter.inc(7)
counter.value  # 10
Подсказки
Задание можно решить разными способами. Нет единственного верного решения. Так что творите!

class Counter(object):
    """A simple integral counter."""

    def __init__(self):
        """Initialize a new counter with zero as starting value."""
        self.value = 0

    def inc(self, amount=1):
        """Increment counter's value."""
        self.value = max(self.value + amount, 0)

    def dec(self, amount=1):
        """Decrement counter's value."""
        self.inc(-amount)


