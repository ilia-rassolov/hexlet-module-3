### 00_create_classe

Реализуйте класс Counter, представляющий собой счётчик, хранящий неотрицательное целочисленное значение и позволяющий 
это значение изменять:

атрибут value должен хранить текущее значение счётчика (вначале равное нулю)
метод inc() должен увеличивать текущее значение на delta единиц (на 1 по умолчанию)
метод dec() должен уменьшать текущее значение на delta единиц (на 1 по умолчанию)
c = Counter()
c.inc()
c.inc()
c.inc(40)
c.value  # 42
c.dec()
c.dec(30)
c.value  # 11
c.dec(delta=100)
c.value  # 0

### 01_methode_init

Вам предстоит снова реализовать класс Counter. Но на этот раз счётчик будет иммутабельным и всё ещё неотрицательным целочисленным. 
Методы inc() и dec() должны возвращать новый счётчик с изменённым в большую или соответственно меньшую сторону значением value 
(по умолчанию счётчик изменяется на единицу).

c = Counter()
c.inc()  # возвращает новый объект класса
c.inc().value  # возвращает value нового объекта
В этой реализации вам нужно объявить в классе функцию-инициализатор, позволяющую задать начальное значение счётчика 
(атрибут value). Если же значение при инстанциировании не будет задано, следует принять его по умолчанию равным нулю.

Атрибут value первоначального объекта после применения методов должен всё ещё содержать неизменное значение.
Неизменность старого объекта и является условием иммутабильности.

c = Counter()
c.inc().inc(5).dec(2).value  # 4

# Старый экземпляр не должен изменяться
d = c.inc(100)
d.dec().value  # 99

forty_two = Counter(42)
forty_two.value  # 42
Внимание! В самом классе атрибут value не должен быть объявлен. Этот атрибут должен добавляться в объект только в инициализаторе.

### 02.HourClock

Реализуйте класс HourClock, который будет изображать часы с одной лишь часовой стрелкой. 
Текущее время (час) должно сообщать свойство hours. Это же свойство должно позволять 
изменять положение часовой стрелки (посредством сеттера). При изменении положения стрелки нужно контролировать,
чтобы значение оставалось в диапазоне 0..11 (часов).

clock = HourClock()
clock.hours  # 0
# в начале часовая стрелка всегда на нуле
clock.hours += 5
# ^ эквивалентно clock.hours = clock.hours + 5
clock.hours += 5
clock.hours  # 10
clock.hours += 5
clock.hours  # 3
clock.hours -= 4
clock.hours  # 11
clock.hours = 123
clock.hours  # 3
Подсказки
Используйте модульную арифметику

### 03.LimitedCounter

Вам дан класс Counter, реализующий счетчик с инкрементом и декрементом. Вам нужно реализовать класс-потомок LimitedCounter,
который будет отличаться от Counter тем, что при инициализации будет принимать в качестве аргумента лимит — 
максимальное возможное значение счетчика.

Требования к классу LimitedCounter:

Класс должен максимально использовать методы предка, если таковые переопределяет
Минимальное значение счетчика Counter — 0, должно оставаться таковым и для LimitedCounter
counter = LimitedCounter(limit=10)
counter.inc()
counter.inc(7)
counter.value  # 8
counter.dec(10)
counter.value  # 0
counter.inc(7)
counter.inc(7)
counter.value  # 10
Подсказки
Задание можно решить разными способами. Нет единственного верного решения. Так что творите!

class Counter(object):
    """A simple integral counter."""

    def __init__(self):
        """Initialize a new counter with zero as starting value."""
        self.value = 0

    def inc(self, amount=1):
        """Increment counter's value."""
        self.value = max(self.value + amount, 0)

    def dec(self, amount=1):
        """Decrement counter's value."""
        self.inc(-amount)


### 04.Exception

Реализуйте декоратор suppress ("подавлять"), который должен перехватывать заданное исключение (одно или кортеж), 
если таковое возникнет при вызове оборачиваемой функции, и возвращать вместо ошибки заданное значение 
(keyword-only аргумент "or_return", значение по умолчанию — None).

@suppress(ZeroDivisionError, or_return=42)
def foo():
     return 1 // 0

foo()  # 42

@suppress((KeyError, IndexError))
def get_item(key, structure):
     return structure[key]

get_item(7, "foo") is None  # True
get_item('a', {}) is None  # True

### 05.Build binary tree

Двоичное дерево — иерархическая структура данных, в которой каждый узел имеет не более двух потомков (детей). 
Как правило, первый называется родительским узлом, а дети называются левым и правым наследниками.

В данном испытании мы будем использовать подвид двоичного дерева — двоичное дерево поиска. Правильное дерево не 
содержит повторяющихся ключей, и для каждого узла гарантируется, что в левом поддереве все значения меньше текущего, 
а в правом — больше.

Реализуйте класс, который представляет собой узел дерева.

Класс должен содержать:

Атрибут key — ключ узла.
Атрибуты left и right — ссылки на левого и правого ребёнка соответственно. Если ребёнок в узле отсутствует, 
геттер возвращает None.
Метод insert(key) — выполняет добавление узла, формируя правильное двоичное дерево.

from solution import Node
tree = Node()
tree.insert(9)
tree.insert(17)
tree.insert(4)
tree.insert(3)
tree.insert(6)
tree.key  # 9
tree.left.key  # 4
tree.right.key  # 17
tree.left.left.key  # 3
tree.left.right.key  # 6

### 06.Binary tree search

Двоичное дерево поиска состоит из узлов, каждый из которых содержит значение ключа и два поддерева (левое и правое), 
которые в свою очередь также являются двоичными деревьями. Правильное дерево не содержит повторяющихся ключей, и для 
каждого узла гарантируется, что в левом поддереве все значения меньше текущего, а в правом — больше.

Двоичное дерево поиска

Реализуйте класс, который реализует представление узла. При инициализации объекта класс принимает на вход три параметра:

key — значение ключа (число),
left — левое поддерево (тоже узел, по умолчанию None),
right — правое поддерево (по умолчанию None).
Каждый экземпляр класса должен содержать атрибуты:
key
left
right

Также класс должен реализовывать метод search(key), который выполняет поиск узла в правильно построенном двоичном дереве
по ключу и возвращает узел. Если узел не найден, возвращается None.

from solution import Node
node5 = Node(5)
node22 = Node(22, left=Node(20))
tree = Node(
    9,
    Node(
        4,
        Node(3),
        Node(
            6,
            node5,
            Node(7),
        ),
    ),
    Node(
        17,
        right=node22,
    ),
)
tree.search(6).key  # 6
tree.search(6).left.key  # 5
tree.search(6).right.key  # 7
tree.search(5) is node5  # True
tree.left.left.key  # 3

# 07.Aggregation binary tree

В данном испытании мы будем использовать двоичное дерево, и выполнять агрегацию данных.

src/solution.py
Реализуйте следующие методы в классе solution.Node:

__len__() — возвращает количество узлов в дереве (используется в len()).
__repr__() — возвращает строковое представление дерева (используется для отображения в REPL).
total() — возвращает сумму всех ключей дерева.
minimum() — возвращает минимальный ключ дерева.
maximum() — возвращает максимальный ключ дерева.
to_list() — возвращает плоский список, содержащий все ключи.
every(fn) — проверяет, удовлетворяют ли все ключи дерева условию, заданному в передаваемой функции.
some(fn) — проверяет, удовлетворяет ли какой-либо ключ дерева условию, заданному в передаваемой функции.
При обходе дерева нужно использовать порядок слева-направо. То есть вначале обрабатываем ключ узла, затем ключ левого 
ребёнка, после чего ключ правого ребёнка.

from solution import Node
tree = Node(
    9,
    Node(
        4,
        Node(8),
        Node(
            6,
            Node(3),
            Node(7),
        ),
    ),
    Node(
        17,
        right=Node(
            22,
            Node(20),
        ),
    ),
)
len(tree)  # 9
tree.total()  # 96
tree.to_list()  # [9, 4, 8, 6, 3, 7, 17, 22, 20]
tree.every(lambda key: key <= 22)  # True
tree.some(lambda key: key > 22)  # False
tree.minimum()  # 3
tree.maximum()  # 22
tree2 = Node(3, Node(1), Node(2))
tree2  # выводится repr(tree2)
# Node(3, Node(1, None, None), Node(2, None, None))



